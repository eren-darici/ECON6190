# -*- coding: utf-8 -*-

# """Project_PartA.ipynb
# 
# Automatically generated by Colab.
# 
# Original file is located at
#     https://colab.research.google.com/drive/1odFVcb4Ggjc7kGsxTzVW-kbCX_6zM8rh
# """

# Add ggplot, dplyr, and stargazer
# Install if missing, then load
packages <- c("ggplot2", "dplyr", "stargazer")

for (pkg in packages) {
  if (!require(pkg, character.only = TRUE)) {
    install.packages(pkg, dependencies = TRUE)
    library(pkg, character.only = TRUE)
  }
}

# """# Part 1"""

# Read data1.csv
DATA_URL <- "https://raw.githubusercontent.com/eren-darici/ECON6190/refs/heads/main/data/data1.csv"
data1 <- read.csv(DATA_URL)

# """### Part 1.i.
# Make sure R can read it correctly and report descriptive statistics (including variance) of
# the two variables in the dataset using R. Provide a scatter plot of the variables using R.
# """

# Make sure R can read it correctly
if (!is.null(data1)) {
  print("data1.csv loaded correctly.")
} else {
  stop("ERROR: data1.csv was not loaded correctly.")
}

# Print descriptive stats including variance
vary <- var(data1$y)
varx <- var(data1$x)
variance_row <- data.frame(x=varx, y=vary)
rownames(variance_row) <- "Variance"

# Turn summary data into data.frame
data1_desc_stats <- do.call(cbind, lapply(data1, summary))

# Append variance row
data1_desc_stats <- rbind(data1_desc_stats, variance_row)

print(data1_desc_stats)

# Use stargazer to print latex
# stargazer(data1_desc_stats, summary=FALSE, rownames = FALSE)

# Create a scatterplot
ggplot(data1, aes(x = x, y = y)) +
  geom_point() +
  labs(
    x = "X",
    y = "Y"
  ) +
  theme_minimal(base_size=20)

# """### Part 1.ii.
# Run a simple two-sided t-test to check for the equality of the means of the y and the x
# variables in the data. Use 5% and 1% levels of significance. Comment on the results -
# whether you reject the null of equal mean or not at 5% level, report test statistic, p-value
# for the test and 95% confidence interval. How does it differ from the 99% CI? Use R and
# report the output.
# """

# 2-sided t-test at 5% percent (assuming variances are not equal)
t_test <- t.test(data1$x, data1$y,
                 alternative = "two.sided",
                 conf.level = .95,
                 var.equal = FALSE)
t_test

# 2-sided t-test at 1% percent (assuming variances are not equal)
t_test <- t.test(data1$x, data1$y,
                 alternative = "two.sided",
                 conf.level = .99,
                 var.equal = FALSE)
t_test

# """# Part 2
# Use seed as the last 4 digits of your student ID number for both (i) and (ii) below.
# """

# Set seed
SEED <- 8900
set.seed(SEED)

# """### Part 2.i.
# Generate 10 random numbers from continuous Uniform distribution with range [0,1]
# and plot the histogram. Compare this to the histogram based on 1000 random
# numbers generated from the same uniform distribution. Report the sample mean and
# plot of histogram in each case.
# """

# Generate 10 random numbers
data.part2i_10 <- runif(10, min=0, max=1)

# Generate 1000 random numbers
data.part2i_1000 <- runif(10, min=0, max=1)

# Bind data
df.part2i <- bind_rows(
  data.frame(value=data.part2i_10, size='10 samples'),
  data.frame(value=data.part2i_1000, size='1000 samples')
)

# Create the histogram
ggplot(df.part2i, aes(x = value, fill = size)) +
  geom_histogram(bins=20, alpha=0.3, position='identity') +
  labs(
    x='Value',
    y='Count',
    fill="Sample Size"
  )

# Sample means
sample_mean_2_10 <- mean(data.part2i_10)
sample_mean_2_1000 <- mean(data.part2i_1000)
print(sample_mean_2_10)
print(sample_mean_2_1000)

# """### Part 2.ii.
# Generate 25 random numbers from a standard normal distribution and plot a
# histogram. Now repeat the process and generate 250 random numbers from the same
# distribution and plot the histogram. Plot kernel density for these 250 random numbers
# with (approx.) optimal bandwidth. Increase and decrease the bandwidth sufficiently
# to illustrate (with a short comment) how the plots changes with bandwidth (make
# sure to present all plots from R in your output.
# """

# Generate standard normal samples
data.part2ii_25 <- rnorm(mean=0, sd=1, n=25)
data.part2ii_250 <- rnorm(mean=0, sd=1, n=250)

# Bind data
df.part2ii <- bind_rows(
  data.frame(value=data.part2ii_25, size='25 samples'),
  data.frame(value=data.part2ii_250, size='250 samples')
)

# Create histogram
ggplot(df.part2ii, aes(x=value, fill=size)) +
  geom_histogram(bins=20, alpha=0.3, position ='identity') +
  labs(
    x='Value',
    y='Count',
    fill="Sample Size"
  )

# Silverman's Rule of Thumb of optimal bandwidth
silverman_bw <- function(x) {
  n <- length(x)
  s <- sd(x)
  iqr <- IQR(x)
  0.9 * min(s, iqr / 1.34) * n^(-1/5)
}

# Find the optimal bandwith
h_opt.250 <- silverman_bw(data.part2ii_250)
print(h_opt.250)

# Bandwidths to compare
bandwidths <- c(0.000001, h_opt.250, 0.5, 1)

# Loop over bandwidths
for (bw in bandwidths) {
  print(
    ggplot(data.frame(x=data.part2ii_250), aes(x=x)) +
      geom_density(color='blue', fill='skyblue', alpha=0.3, bw = bw) +
      labs(
        title = paste("KDE with Bandwidth =", round(bw, 6)),
        x = "Value",
        y = "Density"
      )
  )
}

# """# Part 3
# Use the last 4 digits of your student ID as seed value.
# 
# ### Part 3.i.
# Generate any 5 numbers. Now resample with replacements from these 3 times. Make
# each resample size the same as the original sample size. Use R and report the original
# and the resampled values.
# """

# Create 5 numbers between 1 and 100
original <- sample(1:100, 5)
original

# Print original
print(paste("Original:", paste(original, collapse = " ")))

# Resample 3 time with replacement and print
for (i in 1:3) {
  x <- sample(original, size=length(original), replace=TRUE)
  print(paste("Resample", i, ":", paste(x, collapse = " ")))
}


# -*- coding: utf-8 -*-
# """Project_PartB.ipynb
# 
# Automatically generated by Colab.
# 
# Original file is located at
#     https://colab.research.google.com/drive/12KlGZj5gZYvzSXJjYV9bthBduQqBpgiu
# 
# # Part B
# Use a real-world cross-section data set with a continuous dependent variable (Y), and at least
# 4 independent variables, with at least one being continuous (X1, X2, ..) . Consider the sample
# size to be 120 or more.
# """

# Install packages if not installed
# dplyr: Data manipulation
# stargazer: Regression tables for reporting
# ggplot2: Data visualization
# lmtest: Breuschâ€“Pagan test and other diagnostic tests
# performance: Multicollinearity checks and model diagnostics

packages <- c("dplyr", "stargazer", "ggplot2", "lmtest", "performance")

for (pkg in packages) {
  if (!require(pkg, character.only = TRUE)) {
    install.packages(pkg)
    library(pkg, character.only = TRUE)
  }
}

# Read data
DATA_URL <- "https://raw.githubusercontent.com/eren-darici/ECON6190/refs/heads/main/data/medical_insurance.csv"
data <- read.csv(DATA_URL)
head(data, 5)

# Check missing values
any(is.na(data))

# Select Y (dependent variable)
y <- data$annual_medical_cost

# Select X (6 independent variables)
X <- data[, c("age",
              "bmi",
              "chronic_count",
              "visits_last_year",
              "medication_count",
              "hospitalizations_last_3yrs")]

# Assertion to check missing
stopifnot(nrow(X) == length(y))

# Combine data
model_data <- data.frame(X, y = y)

# """# Part B.i.
# Provide descriptive statistics for all variables including their variances. Run OLS
# regression of Y on all X variables and report the results in a Table. Comment on
# statistical significance of regression coefficients at 10%, 5% and 1% levels? How is
# the overall in-sample fit of the model? Justify.
# """

# Descriptive statistics
describe_func <- function(x) {
  round(c(
    mean = mean(x, na.rm = TRUE),
    sd = sd(x, na.rm = TRUE),
    variance = var(x, na.rm = TRUE),
    min = min(x, na.rm = TRUE),
    q25 = quantile(x, 0.25, na.rm = TRUE),
    median = median(x, na.rm = TRUE),
    q75 = quantile(x, 0.75, na.rm = TRUE),
    max = max(x, na.rm = TRUE)
  ), 4)
}

# Appply function to model data
descriptive_stats <- sapply(model_data, describe_func)
descriptive_stats

# Run OLS
model <- lm(y ~ ., data=model_data)
summary(model)

# Stargazer for better table
stargazer(model, type = "text", title = "OLS Regression Results", report = "vsp*", digits = 6)
# Latex
#stargazer(model, type = "latex", title = "OLS Regression Results", report = "vsp*", digits = 6)

# """# Part B.ii.
# Generate in-sample predictions and compare it to observed Y. [You may use kernel
# density plots for a quick comparison. Provide a brief comment].
# """

# Generate in sample predictions
pred <- predict(model)

# Bind data
data_kde <- data.frame(
  value = c(y, pred),
  type = rep(c("Observed", "Predicted"), c(length(y), length(pred)))
)

# Plot KDE
ggplot(data_kde, aes(x=value, fill=type)) +
  geom_density(alpha=0.4) +
  labs(
    x = "Annual Medical Cost",
    y = "Density"
  )

# """# Part B.iii.
# Run a heteroscedasticity test and report your result with conclusion
# """

# Run BP Test
bp_test <- bptest(model)
bp_test

# """# Part B.iv.
# Run a multicollinearity test and report your result with conclusion.
# """

# Test VIF (Variance Inflation Factor)
vif_values <- check_collinearity(model)
vif_values

# """# Part B.v.
# Drop any 2 independent variables of your choice and run an F-test to explain whether
# you should prefer the restricted (0-type restriction as explained in class) or the
# unrestricted model. Make sure to report your F-test results
# """

# Drop visits_last_year, medication_count
restricted_model_data <- model_data %>%
  select(-visits_last_year, -medication_count)

restricted_model_data

# Run OLS on restricted model
restricted_model <- lm(y ~ ., data=restricted_model_data)
stargazer(restricted_model, type = "text", title = "OLS Regression Results", report = "vsp*", digits = 6)
# Latex
#stargazer(restricted_model, type = "latex", title = "OLS Regression Results", report = "vsp*", digits = 6)

# F-Test
f_test <- anova(restricted_model, model)
stargazer(as.data.frame(f_test), type = "text", title = "OLS Regression Results", digits = 6)
#stargazer(as.data.frame(f_test), type = "latex", title = "OLS Regression Results", digits = 6)

